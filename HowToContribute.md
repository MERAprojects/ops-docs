# How to contribute to the code

## Contents

- [Contributing Changes to OpenSwitch](#contributing-changes-to-openswitch)
	- [Working Behind a Firewall](#working-behind-a-firewall)
	- [Preparing Changes to Be Reviewed](#preparing-changes-to-be-reviewed)
	- [Sending Changes for Review](#sending-changes-for-review)
	- [Resubmitting a Set of Changes](#resubmitting-a-set-of-changes)
- [OpenSwitch Coding Style](#openswitch-coding-style)
	- [Comparisons](#comparisons)
	- [Variables](#variables)
- [OpenSwitch development environment](#openswitch-development-environment)
	- [Managing the Development Environment](#managing-the-development-environment)
		- [Prerequisites for Using Development Environment](#prerequisites-for-using-development-environment)
		- [devenv_init](#devenvinit)
		- [devenv_status](#devenvstatus)
		- [devenv_add](#devenvadd)
		- [devenv_rm](#devenvrm)
		- [devenv_update_recipe](#devenvupdaterecipe)
		- [devenv_clean](#devenvclean)
		- [devenv_list_all](#devenvlistall)
		- [devenv_cscope](#devenvcscope)
		- [devenv_import](#devenvimport)
		- [devenv_patch_recipe](#devenvpatchrecipe)
		- [devenv_rm](#devenvrm)
		- [devenv_refresh](#devenvrefresh)
		- [git_pull](#gitpull)
	- [Working with the Modified Packages](#working-with-the-modified-packages)
		- [Building and Cleaning](#building-and-cleaning)
		- [Building Documents](#building-documents)
		- [Deploying and Undeploying](#deploying-and-undeploying)
		- [Troubleshooting](#troubleshooting)
		- [Understanding the Building System Infrastructure](#understanding-the-building-system-infrastructure)
	- [Working with branches](#working-with-branches)
- [How to add new code to OpenSwitch](#how-to-add-new-code-to-openswitch)
	- [Adding a New Repository](#adding-a-new-repository)
	- [C/C++ code with CMake](#cc-code-with-cmake)
		- [Writing a new daemon with CMake](#writing-a-new-daemon-with-cmake)
	- [Adding a recipe for your daemon](#adding-a-recipe-for-your-daemon)
- [How to setup an NFS root environment for development](#how-to-setup-an-nfs-root-environment-for-development)
	- [Introduction](#introduction)
	- [Setup the NFS server](#setup-the-nfs-server)
	- [Using NFS root](#using-nfs-root)
		- [Configure your NFS server IP address on the image](#configure-your-nfs-server-ip-address-on-the-image)
		- [Deploy your NFS directory](#deploy-your-nfs-directory)
			- [Working with devenv on NFS](#working-with-devenv-on-nfs)
		- [Boot your hardware with NFS](#boot-your-hardware-with-nfs)

## Contributing Changes to OpenSwitch
Changes to the OpenSwitch code base go through a review process before being merged. This page describes how local modifications can be submitted for review and, if approved, made available upstream in the OpenSwitch project.

The [OpenSwitch review site](https://review.openhalon.io/#/admin/projects) is the entry point for changes for review, test and inclusion in one of the OpenSwitch projects.  This site runs [Gerrit](https://code.google.com/p/gerrit/) for online code reviews using the [git](http://git-scm.com/) distributed version control system.

### Working Behind a Firewall
The port used by Gerrit (29418) on the review website may be blocked in some networks. One workaround (besides asking your local IT to open the port) is to tunnel using your http proxy. You can achieve that by modifying your ~/.ssh/config file and adding the following lines (preserve the indentation):

```
Host review.openhalon.io
   ProxyCommand socat - PROXY:<proxy>:%h:%p,proxyport=<proxy-port>
```

For more details and examples adding proxy user/passwords, you can check [this page](http://gitolite.com/git-over-proxy.html).

*NOTE: Be sure you have the socat program installed from your distribution.*

### Preparing Changes to Be Reviewed

Before attempting to commit changes, make sure they are compliant with the [OpenSwitch coding style](#openswitch-coding-style), or for non-OpenSwitch modules the style it uses.  In particular, files with trailing whitespace will be rejected, as will files with non-printable ASCII characters in their names.

Changes for review should be committed to a local branch with a commit message beginning with a single line of text which summarizes the contents of the change (additional description may follow the summarization line as desired, see the guidelines for commit messages).  For instance:

```bash
$ git commit -m "Meaningful summary of this change set."
```

If the change set has been composed by multiple commits to the local branch, consider squashing them into a single commit using `git rebase`.

### Sending Changes for Review

`git-review` is used as an aid when submitting a change set for review.  Normally, `git-review` is configured as part of the `devenv_init` step.  If this was bypassed, see [these instructions](http://www.mediawiki.org/wiki/Gerrit/git-review) for installing and configuring `git-review`.
The commit message for the set of changes must include a "Change-Id", as generated by the "-i" option to `git-review`:
```bash
$ git-review -i
```

###  Resubmitting a Set of Changes

Reviewers may request modifications to the set of changes previously submitted.  Gerrit will append a new change set to an existing review by matching the Change-Id in the commit message. So, to submit the change set after modification, simply omit the "-i" option:
```bash
$ git-review
```
It is also possible to manually add the Change-Id line from the previous commit to a subsequent commit using `git commit --amend`.  It is also possible to abandon a set of changes using the web interface, if that is desired.

## OpenSwitch Coding gStyle

The coding style used for OpenSwitch is an extension of the [Open vSwitch Coding Style](https://github.com/openvswitch/ovs/blob/master/CodingStyle.md), which is itself an extension of the [One True Brace Style](https://en.wikipedia.org/wiki/Indent_style#Variant:_1TBS) for indenting.  The additions below are clarifications and do not conflict with the Open vSwitch style.


### Comparisons
Write comparisons in a form that reads naturally.

```
    bool foob = someBoolFn(x);
    int fooi = someIntFn(x);

    if (true == foob) {  /* No, unnecessary comparison and doesn't read well */
    if (foob) {          /* Yes */

    if (11 == fooi) {    /* No, doesn't read well */
    if (fooi == 11) {    /* Yes */

    if (fooi == 0) {     /* Yes */
    if (!fooi) {         /* Yes */

```

### Variables
Do not do gratuitous initialization of variables.  Doing this prevents the compiler from detecting accidental use before initialization.

```
    struct Goofus *goofus = NULL;   /* Wrong */
    struct Gallant *gallant;        /* Right */
```


## OpenSwitch development environment

In addition to constructing images, the OpenSwitch build system assists in the development process by creating and maintaining an area containing a subset of the project's source files.  Once an OpenSwitch repository has been cloned and configured, working in the development environment may begin, i.e. no need to build the image.

The OpenSwitch development environment is built upon the <code>devtool</code> recently written by Paul Eggleton

**All of the packages in OpenSwitch are not yet supported in the development environment.**

### Managing the Development Environment

The area for developing software will be found under the <code>src/</code> directory at the top level of the workspace.  The subdirectories will contain the source for the packages being worked with.  All targets for the development environment management begin with <code>devenv_</code> and can be shown with tab-completion:
```bash
$ make devenv_<TAB><TAB>
devenv_add            devenv_clean          devenv_import         devenv_init
devenv_patch_recipe   devenv_rm             devenv_status         devenv_update_recipe  
```

#### Prerequisites for Using Development Environment

* Follow the [OpenSwitch coding style](#openswitch-coding-style) for new code, or follow the existing style in non-OpenSwitch modules.
* In order to use the development environment you need to setup an ssh key with the gerrit server at review.openhalon.io. Please refer to  [this page to learn how to manage your ssh keys](#Managing_SSH_keys).
* If you are working behind a proxy, be sure to setup the proxy tunnel as described [here](Contributing_Changes_to_OpenHalon#Working_Behind_a_Firewall).
* If your username for gerrit is different from the username from your local machine, please export REVIEWUSER variable (preferable in some place where it gets always setup, like ~/.bashrc)

```bash
export REVIEWUSER=<your gerrit username>
```

Alternatively, set `gitreview.username`:
```bash
git config --global gitreview.username <GERRIT_USERNAME>
```

*gitreview.username* will be used in preference to the *REVIEWUSER* environment variable if both are set.

* Be sure to have your git configured for contributions:

```bash
git config --global user.email "me@mydomain.com"
git config --global user.name "My Self"
```

#### devenv_init

*Note: Submitting any changes back to the OpenSwitch project will be easier with `git review`.  If installed, `make`-ing the `devenv_init` target will configure the workspace for possible future change submissions.  Please install `git-review` as described in [these instructions](http://www.mediawiki.org/wiki/Gerrit/git-review) now, if it is not already installed on the development machine.*

This <code>src/</code> directory and substructure is created with

```bash
$ make devenv_init
```

#### devenv_status

The <code>devenv_status</code> target may be used to show the status of the development environment, and will work even before the development environment has been initialized.  Typically, the result is

```bash
$ make devenv_status
openvswitch-halon: <path>/src/openvswitch-halon
```

#### devenv_add

Packages to be developed may be added to the collection, one or more at a time, as shown in the following example.  As the packages are added, each one will be fetched into the development <code>src/</code> directory in separate sub-directories. Each package is also unpacked and patched (as required).

```bash
$ make devenv_init
...
$ make devenv_add openvswitch-halon quilt
...
$ make devenv_status
openvswitch-halon: <path>/src/openvswitch-halon
quilt: <path>/src/quilt
```

#### devenv_rm

Complementary to the <code>devenv_add</code> target, the <code>devenv_rm</code> target can be used to remove packages from the collection.  Continuing from the previous example:

```bash
$ make devenv_rm openvswitch-halon
...
$ make devenv_status
quilt: <path>/src/quilt
```

**Note**: Unsaved changes to the source in the removed package will be irretrievably lost.

#### devenv_update_recipe

<code>devenv_update_recipe</code> is used to update build recipes after changes have been committed to a package in the development environment.  The workflow is as follows:

```bash
$ make devenv_init
...
$ make devenv_add openvswitch-halon
... # make changes to src/openvswitch-halon/...
$ make openvswitch-halon-build
...
$ make openvswitch-halon-deploy TARGET="root@xx.xx.xx.xx"
... # test your changes ... they work!
$ git -C src/openvswitch-halon add <the files you changed>
$ git -C src/openvswitch-halon commit -sm "Fix something"
...
$ make devenv_update_recipe openvswitch-halon
... # openvswitch-halon recipe is updated with the changes committed to "Fix something"
```

#### devenv_clean

The complementary target to <code>devenv_init</code>, this target will remove any/all package source as well as the <code>src/</code> directory.
**Note**: Unsaved changes to the source in any/all packages will be irretrievably lost.

#### devenv_list_all

This command is in charge of show the user the list of projects to use with the platform that has been configured.

```
$  make devenv_list_all
Build System for halon

Platform: as5712

  * cfgd
  * config-yaml
  * fand
  * halonutils
  * intfd
  * lacpd
```

#### devenv_cscope

This command is a tool for browsing in development enviroment, it has the same features as cscope for linux, and it is necessary to install the tool from linux before use our command.

```bash
$  make devenv_cscope
```

If you need to install the tool in your linux machine use:

```bash
$  sudo apt-get install cscope
```

#### devenv_import

This command will help the developer to import code, you have to specify the name of the package that you want to import

```bash
$  make devenv_import package_name
```

#### devenv_patch_recipe

If the user is working with a recipe and this recipe is not from our source code; after the user made the commit it will run this command in order to create the necessary patch for our environment.

```bash
$  make devenv_patch_recipe
```

#### devenv_rm

This command will remove the package from the development environment

```bash
$  make devenv_rm package name
```

#### devenv_refresh

This command performs a ‘git pull --rebase’ in all your devenv repos. If you have local changes not staged the git pull will fail, and you will get a warning in red to let you know that particular repo wasn’t updated.

```bash
$  make devenv_refresh
```

#### git_pull

This command performs a ‘git pull --rebase’ in the base git repo and the overlay repos (like enterprisehalon), and if you have a devenv, also on all the repos there (like the previous command).

```bash
$  make git_pull
```

### Working with the Modified Packages

All packages in the workspace will have targets to build, clean, deploy or undeploy, which are formed by prefixing these terms with the package name (which, once again, can be seen with tab completion):

```bash
$ make devenv_init
...
$ make devenv_add openvswitch-halon
...
$ make openvswitch-<TAB><TAB>
openvswitch-build     openvswitch-clean     openvswitch-deploy    openvswitch-undeploy
```

#### Building and Cleaning

After (or even before) modifying the source for a package, the package can be built by using the target with the <code>-build</code> suffix.  The <code>-clean</code> suffixed target for the package is intended to return the package to a clean state, but is not functional at this time.

*Note: The build system will ensure that any prerequisites for this target are updated before the package build takes place.*

#### Building Documents

Install "markdown"

```bash
sudo apt-get install markdown
```

After markdown is installed

```bash
make devenv_init
make devenv_add openvswitch-halon
cd src/openvswitch-halon/build
make dist-docs
```

#### Deploying and Undeploying

By specifying a running target, accessible by SSH, the results of the built package can be installed using the <code>-deploy</code> target.  For example,

```bash
$ make openvswitch-deploy TARGET="root@10.0.2.5"
```

will use SSH as user root to install the results of build openvswitch on the device at address 10.0.2.5.

Sometimes it is valuable to display the deployment progress; this can be done by adding the "-s" option to the TARGET, e.g. <code>TARGET="-s root@10.0.2.5"</code>.
Another option available with deploy which is less-often useful is "-n" to do a dry-run of the deployment without actually deploying the content.

*Note: Deployment of files will fail if they are "busy" on the target.*

Undeploying a package will remove the content from the target device.  It does not replace or restore the original content.  The syntax is similar to that used for deploying.

After you're satisfied with your modifications, see how to [contribute them to the OpenSwitch project](Contributing_Changes_to_OpenSwitch).

#### Troubleshooting

if you are building the project and you get a space error, something like this:

```bash
ERROR: No space left on device or exceeds fs.inotify.max_user_watches?
ERROR: To check max_user_watches: sysctl -n fs.inotify.max_user_watches.
ERROR: To modify max_user_watches: sysctl -n -w fs.inotify.max_user_watches=<value>.
```

In this case you have to check is you have enough space in you hard drive

```bash
$ df -*h
Filesystem                                Size  Used Avail Use% Mounted on
/dev/mapper/lvm_vg-lvm_root_lv  457G  146G  288G  34% /
none                                      4.0K     0  4.0K   0% /sys/fs/cgroup
udev                                      7.8G  4.0K  7.8G   1% /dev
tmpfs                                     1.6G  1.3M  1.6G   1% /run
none                                      5.0M     0  5.0M   0% /run/lock
none                                      7.9G   17M  7.8G   1% /run/shm
none                                      100M   36K  100M   1% /run/user
/dev/sda1                                 453M  121M  305M  29% /boot
```

In case that you have the necessary space you have to modify the file /etc/sysctl.d/30-tracker.conf

```bash
sudo vim /etc/sysctl.d/30-tracker.conf
```
You should increase the value of fs.inotify.max_user_watches; the recommendation is to multiple by 2 the current value

#### Understanding the Building System Infrastructure

In this section we are going to review some aspects around our building system.
One important aspect before we start is that our building system is base in [Yocto Project](https://www.yoctoproject.org/about), so we are not going to explain how yocto works but we are going to include some important aspects that are related with our project.

After you download or clone OpenSwitch in you machine you can see the followings folders and files

```bash
$ ls
COPYING  Makefile  README.md  build/  images/  tools/  yocto/
```

**COPYING**: Within this file you will find information about our license, it is Apache License, you can check any detail about it in [Apache License](http://www.apache.org/licenses/LICENSE-2)

**Makefile**: It is our Makefile

**build/**: This directory contains user configuration files and the output generated by Open Embedded; it is standard configuration.

**images/**: Wihtin this directory you will find symbolic links to all the images that the builder builds. The most important file is openhalon-disk-image-platform.tar.gz

**tools/**: This directory contains tools that are primary used by the build system. In this folder we can find the Rules.make file, it is the core of our Makefile

**yocto/**: This directory contain the core of the build system so inside this directory we can find

```bash
$ cd openhalon/yocto
$ ls
openhalon/  poky/
```

**poky/**: This folder is the core of yocto project you can read about it in the following link [YoctoProject Documentation](http://www.yoctoproject.org/docs/1.6/dev-manual/dev-manual.html)

**openhalon/**: This folder is our core and you can find the following information there:

```bash
$ cd openhalon
$ ls
Rules.make  meta-distro-openhalon/  meta-platform-openhalon-as5712/
certs/       meta-foss-openhalon/    meta-platform-openhalon-genericx86-64/
```

**meta-foss-openhalon/**: This folder contains all the recipes and patch for **Free and Open Source Software**

**meta-distro-opnehalon/**: This folder contains all the recipes and patch related to the distribution. It means that you can find all the recipes related with the core and the kernel of OpenSwitch

**meta-platform-openhalon-XXX/**: This folder contains all the recipes and patch related to specific platform, for example: meta-platform-openhalon-genericx86-64 contains all the things that yocto needs in oder to build a new image for x86 platform.

Inside of every folder we have some structure in order to keep everything in order, for example inside  **meta-platform-openhalon-genericx86-64** we have folder for core recipes, kernel recipes  and some others. It means if you have to change something in the kernel and the change is just for x86 you have to go inside openhalon/yocto/openhalon/meta-platform-openhalon-genericx86-64/recipes-kernel and add you recipe or just add the bbapend file.

### Working with branches

If you need to work with development branches there are a couple of changes that will be required in the workflow. Usually only owners of the respective git repo (project owners) or the members of certain privileged user groups can create new feature branches, and these branches are restricted to have the prefix <code>feature/</code> on it.

For example assume that you are starting to work on the brach <code>foo</code> on the project sysd. If you are the developer creating the branch you will need to use the following commands:

```bash
make devenv_add sysd
cd src/sysd
git review -s # this command setups the gerrit remote
git checkout -b feature/foo # notice the -b flag to create the new branch
git push gerrit feature/foo # After this step the new branch is published!
# do your changes and commit
git commit -s # This step is needed for branch creation even if you do not have any code changes
git review feature/foo # send the review for this branch
```

If you are a developer working on a feature branch (foo) that already exists, your workflow will look like:

``` bash
make devenv_add sysd
cd src/sysd
git pull --rebase # update the local repo to find any new remote branches
git checkout -b feature/foo --track origin/feature/foo
git branch -u origin/feature/foo
# do your changes and commit
git review feature/foo # send the review for this branch
```

If you are a developer planning to merge your branch (source) to another branch (target):

```bash
make devenv_add sysd
cd src/sysd
git checkout [target]
git pull # update the local repo to find any new remote branches
git merge --no-ff [source] # merge the source branch changes to the target
git commit -s --amend # this will modify the commit message to include a ChangeId. Without the ChangeID, commits will not go through
git review  [target] # send the review for target branch. The review for merge will not have any code as this is only a merge
```

## How to add new code to OpenSwitch

OpenSwitch preferred build system for C/C++ applications is CMake. But as the code start using other languages, guidelines will be provide here for them

### Adding a New Repository

To Add a new repository to OpenSwitch. For example, lets say we are adding a repo called "arpmgrd"

1) Git clone project:

```bash
git clone https://review.openhalon.io/infra/project-config
```

2) Create a new file gerrit/acls/openhalon/arpmgrd.config with following contents (Note: The code review and abandon group name should be `<repo name>`-maintainers, as shown in this example):

```bash
[access "refs/heads/*"]
abandon = group Change Owner
abandon = group arpmgrd-maintainers
label-Code-Review = -2..+2 group openhalon-core
label-Workflow = -1..+1 group Change Owner
```

3) The `<repo-name>`-maintainers group for your repo will get created by the project-config-maintainers when they approve the code review.

4) Modify gerrit/projects.yaml to add the repository:

```bash
- project: openhalon/arpmgrd
  description: Arp Manager Daemon
```

5) git commit --signoff
In the commit message please specify the Ubuntu 1 full name of the two users who you wish to add as maintainers of this repo.

6) git review

### C/C++ code with CMake
#### Writing a new daemon with CMake

```
 # Copyright (C) 2015 Hewlett Packard Enterprise Development LP
# All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

cmake_minimum_required (VERSION 2.8.1)

PROJECT(mydaemon)

# Find dependencies using pkg-config
include(FindPkgConfig)
pkg_check_modules(HALONUTILS halonutils)
pkg_check_modules(SYSTEMD systemd)
pkg_check_modules(OVSCOMMON libovscommon)
pkg_check_modules(OVSDB libovsdb)

######## Build and include settings ########
include_directories(
	${PROJECT_BINARY_DIR} ${PROJECT_SOURCE_DIR}
        ${OVSCOMMON_INCLUDE_DIRS}
)

file(GLOB SOURCES
	"src/*.c"
)

add_executable(
	mydaemon
	${SOURCES}
)

target_link_libraries (mydaemon ${HALONUTILS_LIBRARIES}  ${OVSCOMMON_LIBRARIES}
		        ${OVSDB_LIBRARIES}  ${SYSTEMD_LIBRARIES} -lpthread -lrt)

# Install the daemon on bin directory
INSTALL(TARGETS mydaemon
	RUNTIME DESTINATION bin
)
```

####  Adding a recipe for your daemon
This is a example of a recipe

```
SUMMARY = "Halon My Daemon"
LICENSE = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302"

DEPENDS = "halonutils halon-ovsdb"

SRC_URI = "git://openhalon.io/openhalon/mydaemon;protocol=http"

SRCREV="${AUTOREV}"

S = "${WORKDIR}/git"

inherit cmake
```

In the recipes have some important parts, that we are going to mention:
**SUMMARY** = It is just a summary of your recipe.
**LICENSE** = It is the license for your recipe.
**LIC_FILES_CHKSUM** = It is the path of the license file with the md5
**DEPENDS** = In this label we have to include all the dependency that our recipe have in order to compile in this case is depending od halonutils and halon--ovsdb

**SRC_URI** = This is the list of source files -local or remote, yocto supports several protocols like:
* git://
* http://
* https://
* svn://

You can find the complete list in [Yocto Ref Manual])(http://www.yoctoproject.org/docs/current/ref-manual/ref-manual.html)_

**S** = This is the location in the build directory where the recipe souce code resides. It is the work directory.

**inherit** = You can use this variable to inherit the functionality of a class, in our case we need cmake in order to build this recipe.

## How to setup an NFS root environment for development

The OpenSwitch build environment supports working with an NFS root setup that speeds up development workflows. This section provides the instructions to set it up.

### Introduction
NFS Root environment is a setup where your target hardware boots his root file system from a directory on the developer's machine shared over NFS (Network File System).

This setup is very convenient since it requires almost no effort to update the code/configuration on the target when developers are making changes.

### Setup the NFS server
You need to have a Linux host machine that has an NFS server installed. To install the NFS server use the following command on an Debian/Ubuntu machine:
<source lang=bash>
sudo -E apt-get install nfs-kernel-server
</source>

### Using NFS root
The OpenSwitch build system includes logic that simplifies working with NFS root configuration. In order to use it you will require to perform some steps detailed below.

#### Configure your NFS server IP address on the image
By default the build system will create a debug entry on the boot menus of the switch to start with an NFS root, you need to configure the IP address and path to your NFS root for the menu. To do this, use the  file <code>build/nfs.conf</code> on the build directory.

For example to enable automatic detection of the IP address from the main subnet used to reach the internet on your host machine and the default file system deploy location use:

```bash
echo 'NFS_SERVER_IP ??= "${@get_default_ip(d)}"' > build/nfs.conf
echo 'NFS_SERVER_PATH ??= "${BUILD_ROOT}/nfsroot-${MACHINE}"' >> build/nfs.conf
```

You can also specify the IP address directly.

*NOTE:* After changing this file you will need to rebuild your image and re-flash it on the target hardware. As alternative you can manually modify the address on the bootloader before booting.

#### Deploy your NFS directory
The build system includes a make target that will deploy the root file system into a directory with the name <code>nfsroot-{machine}</code> where ''{machine}'' is the name of the platform that you are using. It will also invoke the exportfs tool to publish the exported directory over the NFS server with the right permissions (it may ask for sudo password to perform this operation).

For example, if you are using the AS5712, you will get a directory called <code>nfsroot-as5712</code> with the following command:

```bash
$ make deploy_nfsroot
```

Important notes:
* If you have previously had deployed the NFS root directory, it will give an error message warning that the previous directory will be wipe-out. You will be able to ctrl+c a that point or proceed. Any change that you did to that directory will be lost.
* If you build the image again, the changes are not automatically deployed to the NFS root, you need to run the deploy target again after changing the image (see next section about how to use it with the devenv environment).

##### Working with devenv on NFS
If you are using the developer environment (devenv), you will find a make target for every package named <code>`<package>`-nfs-deploy</code> that will deploy your modified code to the NFS root directory in a similar way that the <code>deploy-target</code> works.

This may keep asking for the local user password, to avoid this, you can install your ssh-key in your own authorized keys:

```bash
cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys
```

#### Boot your hardware with NFS
In platforms that use grub as boot loader you will find a menu entry labeled 'Switch Development -- NFS root'. Select that entry to boot your hardware in NFS root mode.

As explained above, the bootloader that was flashed with the last installation will setup this entry to point to the IP address of the developer's machine and the path to the development directory. You can manually change these values using the editor for the entry on the grub menu if required.
